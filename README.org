:PROPERTIES:
:ID:       d4c60fae-8667-4066-902f-692a61572338
:END:
#+title:       Scripts
#+author:      Artem Smaznov
#+description: Miscalenious scripts
#+startup:     overview
#+property:    header-args :shebang #!/usr/bin/env bash
#+auto_tangle: t

* Table of Contents :toc:
- [[#auto-start][auto-start]]
  - [[#global][Global]]
- [[#cast-to-tv][cast-to-tv]]
- [[#disconnect-controller][disconnect-controller]]
- [[#get-battery][get-battery]]
- [[#get-current-monitor][get-current-monitor]]
- [[#get-geometry-area][get-geometry-area]]
- [[#get-geometry-desktop][get-geometry-desktop]]
- [[#get-geometry-monitor][get-geometry-monitor]]
- [[#get-geometry-window][get-geometry-window]]
- [[#get-ip][get-ip]]
- [[#get-lang][get-lang]]
- [[#get-music][get-music]]
- [[#get-mute][get-mute]]
- [[#get-network-interface][get-network-interface]]
- [[#get-primary-color][get-primary-color]]
- [[#get-song-metadata][get-song-metadata]]
- [[#get-timestamp][get-timestamp]]
- [[#get-trayer-width][get-trayer-width]]
- [[#get-updates][get-updates]]
  - [[#dependencies][Dependencies]]
- [[#get-uptime][get-uptime]]
- [[#get-video-thumbnail][get-video-thumbnail]]
- [[#get-volume][get-volume]]
- [[#get-wm-layout][get-wm-layout]]
- [[#listen-current-workspace][listen-current-workspace]]
- [[#listen-player][listen-player]]
- [[#listen-title][listen-title]]
- [[#listen-wm-layout][listen-wm-layout]]
- [[#listen-wm-title][listen-wm-title]]
- [[#listen-wm-workspaces][listen-wm-workspaces]]
- [[#musictl][musictl]]
- [[#playerctl][playerctl]]
- [[#player-auto-pause][player-auto-pause]]
- [[#record-screen][record-screen]]
- [[#save-to-clipboard][save-to-clipboard]]
- [[#scan-playlists][scan-playlists]]
- [[#screenshot][screenshot]]
- [[#set-lang][set-lang]]
- [[#set-volume][set-volume]]
- [[#set-wallpaper][set-wallpaper]]
- [[#toggle-lang][toggle-lang]]
- [[#toggle-mute][toggle-mute]]
- [[#trigger-confirmation][trigger-confirmation]]
- [[#trigger-countdown][trigger-countdown]]

* auto-start
:PROPERTIES:
:header-args: :shebang #!/usr/bin/env bash :tangle auto-start.sh
:END:
Debug mode
#+begin_src shell
debug=false
#+end_src

#+begin_src shell
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland)
                # blue screen filter
                $XDG_CONFIG_HOME/wlsunset/wlsunset.sh &
                ;;
            ,*) exit 1 ;;
        esac ;;

    x11)
        # screen locker
        # xscreensaver -no-splash &
        # xautolock -time 60 -locker "$HOME/.config/i3lock/i3lock.sh" &
        xss-lock -- "$HOME/.config/i3lock/i3lock.sh" &

        # compositor
        picom -b &

        # hide cursor
        unclutter -jitter 5 &

        # blue screen filter
        redshift-gtk &
        ;;

    ,*) exit 1 ;;
esac
#+end_src

** Global
System Utilities
#+begin_src shell
# dunst &
nm-applet &
blueman-applet &
nextcloud &
#+end_src

Japanese Language Input
#+begin_src shell
fcitx5 -d &
#+end_src

Launch Apps
#+begin_src shell
if ! $debug; then
    paplay "$HOME/public/audio/windows95-startup.wav" &

    /usr/bin/steam-runtime %U &
    qutebrowser &
    emacs &
    # emacsclient -ca '' &

    sleep 10 && "$HOME/.local/bin/set-wallpaper.sh" &
fi
#+end_src

* cast-to-tv
#+begin_src shell :tangle cast-to-tv.sh
media_url="$1"

# variables
#-------------------------------------------------------------------------------
remote_host=nvidia-shield
remote_port=5555
adb_device="$(~/.local/bin/get-ip.sh $remote_host):$remote_port"

# execution
#===============================================================================
adb connect "$adb_device"
adb -s "$adb_device" shell am start -a android.intent.action.VIEW -d "$media_url"
#+end_src

* disconnect-controller
#+begin_src shell :tangle disconnect-controller.sh
# variables
target_device="$1"

# variables
#-------------------------------------------------------------------------------
controllers=(
    "PS4 Magma"
    "PS4 Onyx"
    "Xbox One"
)

# functions
#-------------------------------------------------------------------------------
get_device_mac () {
    device="$1"
    bluetoothctl devices |
        grep "$device" |
        awk '{print $2}' |
        head -1
}

# execution
#===============================================================================
for controller in "${controllers[@]}"; do
    mac_address=$(get_device_mac "$controller")
    bluetoothctl disconnect "$mac_address"
done
#+end_src

* get-battery
List available batteries
#+begin_example shell
upower -e
#+end_example

metric:
+ percentage
+ present
+ state
+ warning-level

device:
+ battery_ps_controller_battery_a0oabo51o62o65o1d
#+begin_src shell :tangle get-battery.sh
metric=$1
device=$2

# execution
#===============================================================================
# upower -i "/org/freedesktop/UPower/devices/battery_ps_controller_battery_a0oabo51o62o65o1d"
upower -i "/org/freedesktop/UPower/devices/$device" |
    grep $metric |
    awk '{print $2}' |
    sed 's/%//'
#+end_src

* get-current-monitor
#+begin_src shell :tangle get-current-monitor.sh
[ "$1" ] && param=$1 || param=name

# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_CONFIG_HOME" ] && export XDG_CONFIG_HOME="$HOME/.config"

# variables
#-------------------------------------------------------------------------------

# functions
#-------------------------------------------------------------------------------

# setup
#-------------------------------------------------------------------------------

# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland) "$XDG_CONFIG_HOME"/hypr/scripts/get-current-monitor.sh "$param" ;;
            *) exit 1 ;;
        esac ;;

    *) exit 1 ;;
esac
#+end_src

* get-geometry-area
#+begin_src shell :tangle get-geometry-area.sh
slurp
#+end_src

* get-geometry-desktop
#+begin_src shell :tangle get-geometry-desktop.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland) exit ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac

exit
#+end_src

* get-geometry-monitor
#+begin_src shell :tangle get-geometry-monitor.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland)
                # active_monitor=$(hyprctl -j activewindow | jq -r .monitor)
                # hyprctl -j monitors | jq -r '.[] | select(.id | contains(0))' | jq -r '"\(.x),\(.y) \(.width)x\(.height)"'
                exit
                ;;
            ,*) exit 1 ;;
        esac ;;

    x11)
        displays=$(xrandr --listactivemonitors |
                       grep '+' |
                       awk '{print $4, $3}' |
                       awk -F'[x/+* ]' '{print $1,$2"x"$4"+"$6"+"$7}')

        IFS=$'\n'
        declare -A display_mode

        for d in ${displays}; do
            name=$(echo "${d}" | awk '{print $1}')
            area="$(echo "${d}" | awk '{print $2}')"
            display_mode[${name}]="${area}"
        done

        unset IFS
        ;;

    ,*) exit 1 ;;
esac

exit
#+end_src

* get-geometry-window
#+begin_src shell :tangle get-geometry-window.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland)
                hyprctl -j activewindow |
                    jq -r '"\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"'
                ;;
            ,*) exit 1 ;;
        esac ;;

    x11)
        # xdotool getactivewindow
        echo 0
        ;;

    ,*) exit 1 ;;
esac
#+end_src

* get-ip
#+begin_src shell :tangle get-ip.sh
target="$1"

# execution
#===============================================================================
if [[ ! $target ]]; then
    curl -s ifconfig.co
    exit
fi

host $target |
    awk '{ print $NF }'
#+end_src

* get-lang
#+begin_src shell :tangle get-lang.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland)
                language=$(hyprctl -j devices |
                               jq -r '.keyboards[] | select(.name | contains("wlr")) .active_keymap')
                case "$language" in
                    'English (US)') echo us;;
                    'Russian') echo ru;;
                    'Japanese') echo jp;;
                    ,*) echo err;;
                esac
                ;;
            ,*) exit 1 ;;
        esac ;;

    x11)
        setxkbmap -query |
            awk '$1=="layout:" {print $2}'
        ;;

    ,*) exit 1 ;;
esac
#+end_src

* get-music
#+begin_src shell :tangle get-music.sh
stat="$1"

# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_MUSIC_DIR" ] && export XDG_MUSIC_DIR="$HOME/Music"

# variables
#-------------------------------------------------------------------------------
usage="""Usage:
    get-music.sh state
    get-music.sh progress
    get-music.sh volume

    get-music.sh flags
    get-music.sh repeat
    get-music.sh random
    get-music.sh single
    get-music.sh consume
    get-music.sh crossfade
    get-music.sh update

    get-music.sh song
    get-music.sh title
    get-music.sh artist
    get-music.sh album

    get-music.sh file
    get-music.sh cover_file
    get-music.sh cover_color

    get-music.sh rating
    get-music.sh play_count
    get-music.sh skip_count
    get-music.sh last_played

    get-music.sh stats """

# functions
#-------------------------------------------------------------------------------
convert_mode () {
    if [ $(mpc status "%$1%") == "on" ]; then
        echo "$2"
    else
        echo -
    fi
}

convert_crossfade () {
    if [ $(mpc crossfade | awk '{print $2}') > 0 ]; then
        echo "$1"
    else
        echo -
    fi
}

convert_update () {
    if mpc status | grep -q 'Updating DB'; then
        echo "$1"
    else
        echo -
    fi
}

get_track_file () {
    relative_file="$(mpc current -f %file%)"

    [ -z "$relative_file" ] && echo "" && return

    absolute_file="$XDG_MUSIC_DIR/$relative_file"
    echo "$absolute_file"
}

get_album_cover_file () {
    track_file="$(get_track_file)"
    [ -z "$track_file" ] && return

    music_track_dir="$(dirname "$track_file")"
    album_cover_file=$(find "$music_track_dir" -type f -name "cover.*" | head -1)
    if [ -z "$album_cover_file" ]; then
        echo "$XDG_MUSIC_DIR/no-cover"
    else
        echo "$album_cover_file"
    fi
}

get_album_cover_color () {
    cover_file="$(get_album_cover_file)"
    ~/.local/bin/get-primary-color.sh "$cover_file"
}

get_flags () {
    flags=(
        $(convert_mode repeat r)
        $(convert_mode random z)
        $(convert_mode single s)
        $(convert_mode consume c)
        $(convert_crossfade x)
        $(convert_update U)
    )

    for flag in "${flags[@]}"; do
        mpd_flags+="$flag"
    done

    echo "[$mpd_flags]"
}

get_progress () {
    music_progress=$(mpc status "%percenttime%" | cut -c-3 | tr -d '[:space:]')
    echo "$music_progress"
}

get_track_metadata () {
    field=$1

    case $field in
        rating)     default=0.5 ;;
        play_count) default=0   ;;
        skip_count) default=0   ;;
    esac

    track_file="$(get_track_file)"
    if [ -z "$track_file" ]; then
         [ "$field" == "last_played" ] && return
         echo $default
         return
    fi

    value="$(~/.local/bin/get-song-metadata.sh $field "$track_file")"

    [ "$value" == '$last_played' ] && return
    [ "$value" == "\$$field" ] && echo $default && return

    echo "$value"
}

get_stats () {
    rating="$(get_track_metadata rating)"
    play_count="$(get_track_metadata play_count)"
    skip_count="$(get_track_metadata skip_count)"
    last_played="$(get_track_metadata last_played)"

    echo """rating: $rating
            play_count: $play_count
            skip_count: $skip_count
            last_played: $last_played
            """ |
        column --table \
            --table-column right
}

# execution
#===============================================================================
case $1 in
    # player info
    state)    mpc status "%state%"  ;;
    progress) get_progress          ;;
    volume)   mpc status "%volume%" ;;

    # flags
    flags)     get_flags              ;;
    repeat)    convert_mode repeat  r ;;
    random)    convert_mode random  z ;;
    single)    convert_mode single  s ;;
    consume)   convert_mode consume c ;;
    crossfade) convert_crossfade    x ;;
    update)    convert_update       U ;;

    # track info
    song)   mpc current -f "%artist% · %title%" ;;
    title)  mpc current -f "%title%"            ;;
    album)  mpc current -f "%album%"            ;;
    artist) mpc current -f "%artist%"           ;;

    # files
    file)        get_track_file        ;;
    cover_file)  get_album_cover_file  ;;
    cover_color) get_album_cover_color ;;

    # mpd-stats
    rating)      get_track_metadata "$stat" ;;
    play_count)  get_track_metadata "$stat" ;;
    skip_count)  get_track_metadata "$stat" ;;
    last_played) get_track_metadata "$stat" ;;

    stats) get_stats ;;

    ,*) echo "$usage"
esac
#+end_src

* get-mute
#+begin_src shell :tangle get-mute.sh
# variables
#-------------------------------------------------------------------------------
stream=$( amixer sget Master |
              grep "%" |
              awk -F'[][]' '{print $4}' |
              sort -u )

# execution
#===============================================================================
case $stream in
    on) echo off ;;
    ,*) echo on ;;
esac
#+end_src

* get-network-interface
#+begin_src shell :tangle get-network-interface.sh
route |
    grep default |
    head -1 |
    awk '{print $8}'
#+end_src

* get-primary-color
#+begin_src shell :tangle get-primary-color.sh
image="$1"
[ $2 ] && colors=$2 || colors=1

# execution
#===============================================================================
convert "$image" -scale $colorsx$colors\! -format %c -colors $colors histogram:info:- | awk '{print $3}'
#+end_src

* get-song-metadata
See ~beet fields~ for a list of available fields
#+begin_src shell :tangle get-song-metadata.sh
field="$1"
music_file="$2"

# execution
#===============================================================================
beet list "path:$music_file" -f "\$$field"
#+end_src

* get-timestamp
#+begin_src shell :tangle get-timestamp.sh
# variables
#-------------------------------------------------------------------------------
timestamp='+%Y-%m-%d_%H-%M-%S'

# execution
#===============================================================================
date "$timestamp"
#+end_src

* get-trayer-width
#+begin_src shell :tangle get-trayer-width.sh
# execution
#===============================================================================
if [ $(pidof trayer) ]; then
    xprop -name panel |
        grep 'program specified minimum size' |
        awk '{print $5}'
else
    echo 0
fi
#+end_src

* get-updates
get-updates
#+begin_src shell :tangle get-updates.sh
# variables
#-------------------------------------------------------------------------------
updates_file="/var/cache/pacman/updates"

# setup
#-------------------------------------------------------------------------------
if [ ! -f "$updates_file" ]; then
    echo "Error: $updates_file is missing!"
    exit 1
fi

# execution
#===============================================================================
cat "$updates_file" |
    wc -l
#+end_src

get-update-flags
#+begin_src shell :tangle get-update-flags.sh
# variables
#-------------------------------------------------------------------------------
updates_file="/var/cache/pacman/updates"

# setup
#-------------------------------------------------------------------------------
cat "$updates_file" | grep -q "wine"      && flag+=w
cat "$updates_file" | grep -q "mesa"      && flag+=m
cat "$updates_file" | grep -q "linux-zen" && flag+=k

# execution
#===============================================================================
echo "$flag"
#+end_src

** Dependencies
~/opt/pacman/refresh-updates.sh~
#+begin_src shell
checkupdates --nocolor > /var/cache/pacman/updates || true
#+end_src

Run after using pacman
~/etc/pacman.d/hooks/refresh-updates.hook~
#+begin_src conf
[Trigger]
Operation = Install
Operation = Upgrade
Operation = Remove
Type = Package
Target = *

[Action]
Description = Refreshing updates cache
When = PostTransaction
Exec = /bin/sh -c '/opt/pacman/refresh-updates.sh'
#+end_src

Run every 15 min
~crontab -e~
#+begin_src cron
*/15 * * * * /opt/pacman/refresh-updates.sh
#+end_src

* get-uptime
#+begin_src shell :tangle get-uptime.sh
uptime --pretty |
    sed -e 's/up //' \
        -e 's/ \([a-z]\)\w*,*/\1/g' |
    awk '{print $1 " " $2}'
#+end_src

* get-video-thumbnail
#+begin_src shell :tangle get-video-thumbnail.sh
video_file="$1"
size="$2"

# variables
#-------------------------------------------------------------------------------
[ -z "$video_file" ] && echo "[ERROR] video file required as an argument" && exit 1
[ -z "$size" ] && size=300

# execution
#===============================================================================
ffmpeg \
    -i "$video_file" \
    -ss 00:00:05 \
    -vframes 1 \
    -vf "thumbnail,crop=min(iw\,ih):min(iw\,ih),scale=$size:$size" \
    -loglevel quiet \
    -y \
    /tmp/thumbnail.jpg
#+end_src

* get-volume
#+begin_src shell :tangle get-volume.sh
amixer sget Master |
    grep "%" |
    awk -F'[][]' '{print $2}' |
    tr -d '%' |
    sort -r |
    head -1
#+end_src

* get-wm-layout
#+begin_src shell :tangle get-wm-layout.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    wayland)
        case $XDG_SESSION_DESKTOP in
            Hyprland)
                hyprctl getoption -j general:layout |
                    jq -r .str
                ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac
#+end_src

* listen-current-workspace
active workspace
#+begin_src shell :tangle listen-current-workspace.sh
xprop -spy -root _NET_CURRENT_DESKTOP |
    while read workspace_index; do
        echo $workspace_index |
            awk '{print $3}'
    done
#+end_src

* listen-player
#+begin_src shell :tangle listen-player.sh
player="$2"

# variables
#-------------------------------------------------------------------------------
player_arg=""
[ -n "$player" ] && player_arg="--player=$player"

# functions
#-------------------------------------------------------------------------------
listen_metadata () {
    playerctl metadata \
        --follow \
        "$player_arg" \
        --format "{{$1}}"
}

listen_metadata_lc () {
    playerctl metadata \
        --follow \
        "$player_arg" \
        --format "{{lc($1)}}"
}

listen_metadata_path () {
    playerctl metadata \
        --follow \
        "$player_arg" \
        --format "{{$1}}"
}

listen_metadata_icon () {
    playerctl metadata \
        --follow \
        "$player_arg" \
        --format "{{emoji($1)}}"
}

listen_album_color () {
    listen_metadata "$1" | while read -r cover_file; do
        ~/.local/bin/get-primary-color.sh "$cover_file"
    done
}

listen_mpd_event () {
    event="$1"
    field="$2"

    ~/.local/bin/get-music.sh "$field"

    mpc idleloop "$event" | while read -r line; do
        ~/.local/bin/get-music.sh "$field"
    done
}

# execution
#===============================================================================
case $1 in
    # player info
    state)       listen_metadata_lc   status     ;;
    player)      listen_metadata_lc   playerName ;;
    state_icon)  listen_metadata_icon status     ;;
    volume_icon) listen_metadata_icon volume     ;;

    # flags
    loop)      listen_metadata_lc       loop      ;;
    shuffle)   listen_metadata_lc       shuffle   ;;
    flags)     listen_mpd_event options flags     ;;
    repeat)    listen_mpd_event options repeat    ;;
    random)    listen_mpd_event options random    ;;
    single)    listen_mpd_event options single    ;;
    consume)   listen_mpd_event options consume   ;;
    crossfade) listen_mpd_event options crossfade ;;
    update)    listen_mpd_event update  update    ;;

    # track info
    title)    listen_metadata title        ;;
    artist)   listen_metadata artist       ;;
    album)    listen_metadata album        ;;
    volume)   listen_metadata volume       ;;
    progress) listen_metadata position     ;;
    duration) listen_metadata mpris:length ;;

    # files
    track_file)  listen_metadata_path      xesam:url    ;;
    cover_file)  listen_metadata           mpris:artUrl ;;
    cover_color) listen_album_color        mpris:artUrl ;;

    # mpd-stats
    rating)      listen_mpd_event player rating      ;;
    play_count)  listen_mpd_event player play_count  ;;
    skip_count)  listen_mpd_event player skip_count  ;;
    last_played) listen_mpd_event player last_played ;;

    ,*) listen_metadata $1 ;;
esac
#+end_src

* listen-title
#+begin_src shell :tangle listen-title.sh
xprop -spy -root _NET_ACTIVE_WINDOW |
    while read window_id
    do
        echo $window_id |
            awk '{print "getwindowname " $5}' |
            xdotool -
    done
#+end_src

* listen-wm-layout
#+begin_src shell :tangle listen-wm-layout.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    x11)
        case $DESKTOP_SESSION in
            xmonad)
                xprop -spy -root _XMONAD_LOG |
                    stdbuf -oL sed 's/^.*= //' |
                    stdbuf -oL sed 's/^"\(.*\)"$/\1/' |
                    stdbuf -oL awk -F'::::' '{ print $2 }'
                ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac

exit 0
#+end_src

* listen-wm-title
#+begin_src shell :tangle listen-wm-title.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    x11)
        case $DESKTOP_SESSION in
            xmonad)
                xprop -spy -root _XMONAD_LOG |
                    stdbuf -oL sed 's/^.*= //' |
                    stdbuf -oL sed 's/^"\(.*\)"$/\1/' |
                    stdbuf -oL awk -F'::::' '{ print $3 }'
                ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac

exit 0
#+end_src

* listen-wm-workspaces
#+begin_src shell :tangle listen-wm-workspaces.sh
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    x11)
        case $DESKTOP_SESSION in
            xmonad)
                xprop -spy -root _XMONAD_LOG |
                    stdbuf -oL sed 's/^.*= //' |
                    stdbuf -oL sed 's/^"\(.*\)"$/\1/' |
                    stdbuf -oL awk -F'::::' "{ print \$1 }"
                ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac

exit 0
#+end_src

#+begin_src shell :tangle listen-wm-workspaces.sh :tangle no
# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    x11)
        case $DESKTOP_SESSION in
            xmonad)
                xprop -spy -root _XMONAD_LOG |
                    stdbuf -oL sed 's/^.*= //' |
                    stdbuf -oL sed 's/^"\(.*\)"$/\1/' |
                    stdbuf -oL awk -F'::::' "{ print \"[\\\"\" \$1 \"\\\"]\" }" |
                    stdbuf -oL sed 's/ /\", \"/g'
                ;;
            ,*) exit 1 ;;
        esac ;;

    ,*) exit 1 ;;
esac

exit 0
#+end_src

* musictl
#+begin_src shell :tangle musictl.sh
seek="$2"

# execution
#===============================================================================
case $1 in
    toggle)    mpc toggle       ;;
    stop)      mpc stop         ;;
    prev)      mpc prev         ;;
    next)      mpc next         ;;
    goto)      mpc seek "$seek" ;;

    repeat)    mpc repeat       ;;
    random)    mpc random       ;;
    single)    mpc single       ;;
    consume)   mpc consume      ;;

    vol-up)    mpc volume +2    ;;
    vol-down)  mpc volume -2    ;;
esac
#+end_src

* playerctl
#+begin_src shell :tangle playerctl.sh
# player="$2"

# execution
#===============================================================================
case $1 in
    toggle)    playerctl play-pause   ;;
    stop)      playerctl stop         ;;
    prev)      playerctl previous     ;;
    next)      playerctl next         ;;

    vol-up)    playerctl volume 0.02+ ;;
    vol-down)  playerctl volume 0.02- ;;
esac
#+end_src

* player-auto-pause
Requirements
#+begin_src shell
sudo pacman -S mpv-mpris playerctl
paru -S mpd-mpris
#+end_src
or (~mpdris2~ doesn't show embedded album covers)
#+begin_src shell
paru -S mpdris2
#+end_src

Systemd service
#+begin_src conf :shebang :tangle ~/.config/systemd/user/player-auto-pause.service
[Unit]
Description=Pause all MPRIS players when new one starts

[Service]
Type=simple
ExecStart=/home/artem/.local/bin/player-auto-pause.sh

[Install]
WantedBy=default.target
#+end_src

Running script
#+begin_src shell :tangle player-auto-pause.sh
# functions
#-------------------------------------------------------------------------------
function get_all_players {
    playerctl --list-all
}

function get_current_player {
    playerctl --list-all | head -1
}

function get_player_state {
    player="$1"
    playerctl --player "$player" status
}

function pause_players_except {
    new_player="$1"
    players=$(get_all_players)

    for player in $players; do
        if [ "$player" != "$new_player" ]; then
            pause_player "$player"
        fi
    done
}

function pause_player {
    player=$1

    echo "[INFO] pausing player: $player"
    playerctl --player "$player" pause
}

last_player=""

# execution
#===============================================================================
while true; do
    new_player=$(get_current_player)
    new_player_state=$(get_player_state $new_player)

    if [[ "$new_player" != "$last_player" && "$new_player_state" == "Playing" ]]; then
        last_player="$new_player"
        pause_players_except "$new_player"
    fi

    sleep 1
done
#+end_src

Enabling
#+begin_src shell
sudo systemctl daemon-reload
systemctl --user enable --now player-auto-pause.service
#+end_src

* record-screen
#+begin_src shell :tangle record-screen.sh
scope="$1"

# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_VIDEOS_DIR" ] && export XDG_VIDEOS_DIR="$HOME/Videos"

# variables
#-------------------------------------------------------------------------------
record_dir="$XDG_VIDEOS_DIR/recordings"
record_name="recording"
record_format="mp4"
record_file="$record_dir/$record_name-$(~/.local/bin/get-timestamp.sh).$record_format"
record_delay=3

mkdir -p "${record_dir}"

# Audio Settings
audio_device='alsa_output.usb-Focusrite_Scarlett_2i2_USB_Y86EP6H211E46C-00.analog-stereo.monitor'

# Xorg

# Video Settings
resolution='1920x1080'
fps='30'

# functions
#-------------------------------------------------------------------------------
xorg_capture() {
    ffmpeg \
        -video_size $resolution -framerate $fps \
        -f x11grab -i "$DISPLAY" \
        -f pulse -ac 2 -i $audio_device \
        -codec:v libx264 -preset ultrafast \
        -codec:a copy \
        $record_dir/screenrecording-$(~/.local/bin/get-timestamp.sh).mkv
}

Setup
#-------------------------------------------------------------------------------
case $scope in
    monitor)
        message="Active monitor"
        geometry=$(~/.local/bin/get-geometry-monitor.sh) || exit 1
        ;;
    area)
        message="Area selection"
        geometry=$(~/.local/bin/get-geometry-area.sh) || exit 1
        ;;
    window)
        message="Active window"
        geometry=$(~/.local/bin/get-geometry-window.sh) || exit 1
        ;;
    desktop)
        message="Full desktop"
        geometry=$(~/.local/bin/get-geometry-desktop.sh) || exit 1
        ;;
    ,*)
        echo -e """error: invalid option '$scope'

accepted options:
  - monitor
  - area
  - window
  - desktop"""
        exit 1
        ;;
esac

# execution
#===============================================================================
~/.local/bin/trigger-countdown.sh $record_delay

if [[ $geometry ]]; then
    wf-recorder --audio="$audio_device" --file="$record_file" -g "$geometry" || exit 1
else
    wf-recorder --audio="$audio_device" --file="$record_file" || exit 1
fi

notify-send --urgency=low "Recording saved!" "$message"
#+end_src

* save-to-clipboard
#+begin_src shell :tangle save-to-clipboard.sh
type="$1" # image/png
# screenshot.sh monitor | save-to-clipboard.sh image/png

# execution
#===============================================================================
case "$XDG_SESSION_TYPE" in
    wayland) wl-copy -t "$type" ;;

    x11) xclip -selection clipboard -t "$type" ;;

    ,*) err "Unknown display server" ;;
esac
#+end_src

* scan-playlists
#+begin_src shell :tangle scan-playlists.sh
# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_MUSIC_DIR" ] && export XDG_MUSIC_DIR="$HOME/Music"
[ ! "$XDG_CONFIG_HOME" ] && export XDG_CONFIG_HOME="$HOME/.config"

# variables
#-------------------------------------------------------------------------------
music_dir="$XDG_MUSIC_DIR"
playlists_dir="$XDG_CONFIG_HOME/mpd/playlists"

# setup
#-------------------------------------------------------------------------------
cd "$music_dir" || exit 1

# execution
#===============================================================================
echo "Broken song links:"
echo "------------------"
for playlist in "$playlists_dir"/*; do
    playlist=$(basename "$playlist" .m3u)

    while read -r song; do
        ls "$song" &>/dev/null || echo "$playlist: $song"
    done <"$playlists_dir/$playlist.m3u"
done
#+end_src

* screenshot
#+begin_src shell :tangle screenshot.sh
scope="$1"

# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_PICTURES_DIR" ] && export XDG_PICTURES_DIR="$HOME/Pictures"

# variables
#-------------------------------------------------------------------------------
screen_dir="$XDG_PICTURES_DIR/screenshots"
screen_name="screenshot"
screen_format="png"

shutter="/usr/share/sounds/freedesktop/stereo/camera-shutter.oga"

# functions
#-------------------------------------------------------------------------------
set_screen_file() {
    timestamp=$(~/.local/bin/get-timestamp.sh)
    screen_file="$screen_dir/$screen_name-$timestamp.$screen_format"
}

screenshot_wayland() {
    set_screen_file
    if [[ ! $geometry ]]; then
        grim "$screen_file" || exit 1
    else
        grim -g "$geometry" "$screen_file" || exit 1
    fi

    paplay "$shutter"
}

screenshot_xorg() {
    exit 1
    maim -u --geometry "$geometry" | tee "$screen_file" | ~/.local/bin/save-to-clipboard.sh image/png || exit 1
    maim -u --capturebackground -i $(xdotool getactivewindow) | tee "$screen_file" | ~/.local/bin/save-to-clipboard.sh image/png || exit 1
    maim -u --capturebackground --select -n | tee "$screen_file" | ~/.local/bin/save-to-clipboard.sh image/png || exit 1
    maim -u | tee "$screen_file" | ~/.local/bin/save-to-clipboard.sh image/png || exit 1
}

screenshot_android() {
    remote_host="$1"
    remote_port="$2"

    screen_name="tv-screenshot"
    screen_format="png"
    set_screen_file

    remote_dir="/sdcard/Pictures/Screenshots"
    remote_file="$remote_dir/$screen_name.$screen_format"

    adb_device="$(~/.local/bin/get-ip.sh $remote_host):$remote_port"

    adb connect "$adb_device"
    adb -s "$adb_device" shell mkdir -p "$remote_dir"
    adb -s "$adb_device" shell screencap -p "$remote_file"
    paplay "$shutter"
    adb -s "$adb_device" pull "$remote_file" "$screen_file"
    adb -s "$adb_device" shell rm "$remote_file"
}

# setup
#-------------------------------------------------------------------------------
case $scope in
    monitor)
        message="Active monitor"
        geometry=$(~/.local/bin/get-geometry-monitor.sh) || exit 1
        ;;
    area)
        message="Area selection"
        geometry=$(~/.local/bin/get-geometry-area.sh) || exit 1
        ;;
    window)
        message="Active window"
        geometry=$(~/.local/bin/get-geometry-window.sh) || exit 1
        ;;
    desktop)
        message="Full desktop"
        geometry=$(~/.local/bin/get-geometry-desktop.sh) || exit 1
        ;;
    tv)
        message="TV"
        ;;
    ,*)
        echo -e """error: invalid option '$scope'

accepted options:
  - monitor
  - area
  - window
  - desktop
  - tv"""
        exit 1
        ;;
esac

# execution
#===============================================================================
mkdir -p "${screen_dir}"

case $scope in
    tv) screenshot_android nvidia-shield 5555 ;;
    ,*) case $XDG_SESSION_TYPE in
           wayland) screenshot_wayland ;;
           x11) screenshot_xorg ;;
       esac
       ;;
esac

notify-send --urgency low "Screenshot saved!" "$message" --icon "$screen_file"
#+end_src

* set-lang
#+begin_src shell :tangle set-lang.sh
#
# Usage: set-lang.sh [language]
# Examples:
# - set-lang.sh jp
# - set-lang.sh en

# execution
#===============================================================================
setxkbmap -layout $1

if [ $(eww ping 2> /dev/null) == "pong" ]; then
    eww update kbd=$1
fi
#+end_src

* set-volume
#+begin_src shell :tangle set-volume.sh
#
# Usage: set-volume.sh [+-] [%step]
# Examples:
# - set-volume.sh + 2
# - set-volume.sh - 1

direction=$1
step=$2

# execution
#===============================================================================
amixer -q sset Master ${step}%${direction} unmute
#+end_src

* set-wallpaper
#+begin_src shell :tangle set-wallpaper.sh
wallpaper_category=$1

# environment variables
#-------------------------------------------------------------------------------
[ ! "$XDG_PICTURES_DIR" ] && export XDG_PICTURES_DIR="$HOME/Pictures"
[ ! "$XDG_STATE_HOME" ] && export XDG_STATE_HOME="$HOME/.local/state"

# variables
#-------------------------------------------------------------------------------
wallpaper_category_file="$XDG_STATE_HOME/wallpaper"
wallpapers_dir="$XDG_PICTURES_DIR/wallpapers"

# functions
#-------------------------------------------------------------------------------
function getLastCategory {
    last_category="faded"
    if [ -f "$wallpaper_category_file" ]; then
        last_category=$(cat "$wallpaper_category_file")
    fi
}

function handleCategoryInput {
    wallpaper_category="$1"
    if [ ! "$wallpaper_category" ]; then
        wallpaper_category="$last_category"
    fi
}

function updateStateFile {
    caterogy="$1"
    echo "$caterogy" >"$wallpaper_category_file"
}

function selectRandomWallpaper {
    category="$1"
    # wallpaper=$(find "$wallpapers_dir/$category" -type f,l | shuf -n 1)
    wallpaper=$(find "$wallpapers_dir/$category" -type f | shuf -n 1)
}

# functions - x11
#-------------------------------------------------------------------------------
function setNitrogen {
    monitors=$(xrandr --query |
                   grep -e '\sconnected' |
                   awk '{print $1}')

    for monitor in $monitors; do
        nitrogen --set-zoom-fill --random --head="$monitor" "$wallpapers_dir/$wallpaper_category"
    done
}

# functions - wayland
#-------------------------------------------------------------------------------
function setHyprPaper {
    monitors=$(hyprctl -j monitors | jq -r '.[].name')

    [ ! "$(pidof hyprpaper)" ] && hyprpaper &

    hyprctl hyprpaper unload all

    for monitor in $monitors; do
        selectRandomWallpaper "$wallpaper_category"
        hyprctl hyprpaper preload "$wallpaper"
        hyprctl hyprpaper wallpaper "$monitor,$wallpaper"
    done
}

function setWPaperD {
    config_file="$XDG_CONFIG_HOME/wpaperd/wallpaper.toml"
    sed -i "s|path = .*$|path = \"$wallpapers_dir/$wallpaper_category\"|" "$config_file"

    # restart wpaperd
    [ "$(pidof wpaperd)" ] && killall wpaperd
    wpaperd
}

# execution
#===============================================================================
getLastCategory
handleCategoryInput "$wallpaper_category"
updateStateFile "$wallpaper_category"

case $XDG_SESSION_TYPE in
    wayland)
        setWPaperD
        ;;

    x11)
        export DISPLAY=":0"
        setNitrogen
        ;;

    ,*) exit 1 ;;
esac
#+end_src

* toggle-lang
#+begin_src shell :tangle toggle-lang.sh
# variables
#-------------------------------------------------------------------------------
scripts_dir="$HOME/.local/bin"

# functions - x11
#-------------------------------------------------------------------------------
toggle_x11 () {
    case $("$scripts_dir/get-lang.sh") in
        'us') new_lang='ru' ;;
        'ru') new_lang='jp' ;;
        'jp') new_lang='us' ;;
        *) new_lang='us' ;;
    esac

    "$scripts_dir/set-lang.sh $new_lang"

    case $new_lang in
        'jp') fcitx5-remote -o ;; # enable japanese
        *) fcitx5-remote -c ;;    # disable japanese
    esac
}

# functions - wayland
#-------------------------------------------------------------------------------
toggle_wayland () {
    case $XDG_CURRENT_DESKTOP in
        'Hyprland') toggle_hyprland ;;
    esac
}

toggle_hyprland () {
    keyboard_device="massdrop-inc.-ctrl-keyboard"
    hyprctl switchxkblayout "$keyboard_device" next
    case $("$scripts_dir/get-lang.sh") in
        'Japanese') fcitx5-remote -o ;; # enable japanese
        *) fcitx5-remote -c ;;          # disable japanese
    esac
}

# execution
#===============================================================================
case $XDG_SESSION_TYPE in
    x11) toggle_x11 ;;
    wayland) toggle_wayland ;;
esac
#+end_src

* toggle-mute
#+begin_src shell :tangle toggle-mute.sh
amixer -q sset Master toggle
#+end_src

* trigger-confirmation
#+begin_src shell :tangle trigger-confirmation.sh
prompt="$1"

# execution
#===============================================================================
echo -e "Yes\nNo" |
    rofi -dmenu -i -p "$prompt"
#+end_src

* trigger-countdown
#+begin_src shell :tangle trigger-countdown.sh
duration=$1

# execution
#===============================================================================
while (( $duration > 0 )); do
    notify-send "Starting recording in" "$duration"

    sleep 1
    dunstctl close
    ((duration--))
done
#+end_src

